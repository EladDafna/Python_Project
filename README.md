# Python Client-Server Project

## Overview

This project is a Python-based client-server application designed to simulate a network of water stations, each equipped with alarms that report their status to a central server. The project demonstrates key concepts in network programming, file handling, and database management using Python. The communication between clients and the server is managed using sockets, and the server stores the data received from clients in an SQLite database.

## Project Structure

The project consists of the following key files:

1. **server.py:** Represents the server, responsible for receiving data from clients and storing it in an SQLite database.
2. **client.py:** Represents a single client. Multiple copies of this file can be run simultaneously from different directories to simulate multiple clients.
3. **status.txt:** A text file representing the data of a client. Each client has its own `status.txt` file with a unique station ID and alarm statuses.
4. **data.sqlite:** The SQLite3 database used by the server to store data about the clients. This file is generated by `server.py` on its first run if it does not already exist.

## Detailed Explanation

### 1. **Client (`client.py`):**

- The client script runs in a continuous loop, reading data from its `status.txt` file every 60 seconds (or a different interval defined by a global variable). The data in `status.txt` includes the station ID, the state of Alarm1, and the state of Alarm2.
- After reading the data, the client connects to the server via a socket and sends the data as an encoded string in the format `"ID ALARM1 ALARM2"`.
- The client then closes the `status.txt` file, allowing the file to be modified externally between iterations. This feature enables the user to manually change the data in `status.txt` while the client is running, affecting the data sent to the server in subsequent iterations.
- To simulate multiple clients, you can copy `client.py` and `status.txt` into different folders, modify the data in each `status.txt`, and run each client instance separately.

### 2. **Server (`server.py`):**

- The server script opens or creates the `data.sqlite` database file and sets up a table named `station_status` if it does not already exist. The table has the following columns:
  - `station_id`: The ID of the station (primary key).
  - `last_date`: The last time the server received data from the station, stored as a text string in the format "YYYY-MM-DD HH:mm".
  - `alarm1`: An integer representing the state of Alarm1 (0 for OFF, 1 for ON).
  - `alarm2`: An integer representing the state of Alarm2 (0 for OFF, 1 for ON).
- After setting up the database, the server enters a loop where it waits to receive data from clients. When data is received, the server parses the data, checks if a record for the station ID already exists, and either inserts a new record or updates the existing one using the `INSERT OR REPLACE` SQL query.
- The server is designed to handle multiple clients simultaneously, each sending data from its own copy of `client.py`.
- The server also includes error handling to manage exceptions such as client disconnections or crashes, ensuring the server remains operational.

### 3. **status.txt:**

- This file contains three lines:
  1. The station ID (an integer).
  2. The state of Alarm1 (0 for OFF, 1 for ON).
  3. The state of Alarm2 (0 for OFF, 1 for ON).
- The data in this file can be manually edited while the client is running, allowing dynamic changes to the data sent to the server.

### 4. **data.sqlite:**

- This SQLite3 database is used by the server to store the status of each station. It is automatically generated by the server on its first run if it does not exist.

## Usage Instructions

To use this project, follow these steps:

1. **Server Setup:**
   - Run `server.py` to start the server. The server will create the `data.sqlite` database and start listening for connections from clients.

2. **Client Setup:**
   - Copy `client.py` and `status.txt` to a separate directory for each client instance you wish to run.
   - Modify the `status.txt` file to reflect the unique ID and alarm status for each client.
   - Run `client.py` in each directory to start the clients. The clients will read their `status.txt` files and send data to the server every 60 seconds.

3. **Monitor the Server:**
   - The server will update the `data.sqlite` database with the latest data from each client. You can use any SQLite viewer to inspect the data stored in the database.

## Conclusion

This project demonstrates a basic but functional client-server architecture in Python, using sockets for communication and SQLite for data storage. It serves as an example of how to handle multiple clients in a networked environment, with real-time data updates and persistent storage.
